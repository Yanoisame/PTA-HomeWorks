#################常用算法#################
1.判断是否为素数(只有1和本身能被整除)
 A.通过定义函数模块进行解题(注意缩进！！！！)
  def is_prime(num):
      if num == 1:   #排除特殊情况
         return False
      else:
           for 循环变量 in range(2, int(num**0.5 + 1)):  #把这个数前面的数字挨个抽出来
               if num % 循环变量 == 0:   #表示这个区间内有除得尽数，故不是素数，返回假
                  return False
           return True     #循环完成，发现区间内没有除得尽数，所以是素数

  B.衍生题型:区间内的所有素数
  整体思路:把区间内所有数字抽出来(包括端点)，在循环区间每个数字时候，调用上述的素数判断函数，符合要求的增加进列表里，最后解包输出

  a, b = map(int, input.split())     #把输入的两个以空格分开的数字转成map类型的可迭代对象
  lst = []   #创建个空列表，来保存素数
  for 循环变量 in range(a, b+1):      #把区间(包括端点)内数字挨个抽出来给循环变量
      if is_prime(循环变量):          #调用判断素数函数，确定该数字是否为素数
         lst.append(循环变量)         #把符合的数字加入到列表中，如果不符合，什么也不用做
  print(*lst)        #最后解包出该区间内所有素数


2.斐波那契数列(利用递归法实现，返回斐波那契数列中第n项的值)
 A.通过定义函数模块进行解题
  def fib(n):       #传入项数为参数
      if n == 0:    #排除特殊情况，我们判断n是否为0或1，如果是，我们直接返回0或1，因为这两项的值分别为0和1
         return 0
      elif n == 1:
           return 1
      else:         #如果不是上述特殊情况，返回第n-1项和第n-2项的和，这正是斐波那契数列的定义
           return fib(n-1) + fib(n-2)


3.判断水仙花数(拿出每位数的3次方之和是否相等)
 A.通过定义函数模块实现
 def is_sxh(n):  #传入某个数
     num_1 = n // 100 % 10   #提取百位
     num_2 = n // 10 % 10    #提取十位
     num_3 = n % 10          #提取个位
     if num_1**3 + num_2**3 + num_3**3 == n:   #每位数的4次方之和是否等于本身
        return Ture          #等于话，是水仙花数，返回真
     else:                   #否则返回假
          return False

 B.衍生题型(玫瑰花数，拿出每位数的4次方之和是否相等)
 整体思路，与水仙花数类似的题型，提起每一位数后，要做什么
 def mgh(n)
     num_0 = n // 1000       #提取千位(千位以上后只用整除单位，万位就是:n//10000)
     num_1 = n // 100 % 10   #提取百位
     num_2 = n // 10 % 10    #提取十位
     num_3 = n % 10          #提取个位
     if num_0**4 + num_1**4 + num_2**4 + num_3**4 == n:  #判断每位数的4次方之和是否等于本身
        return True  #等于话，是玫瑰花数，返回真
     else:           #否则返回假
          return False


4.最大公约数与最小公倍数(如果同时需要最大公约数和最小公倍数话，分两部分写，提高容错率)
 A.最大公约数部分
  def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a
 A1.最小公倍数部分
   def lcm(a, b):
    return a * b // gcd(a, b)

 B.只需要最小公倍数功能时
    def lcm(a, b):
    m = a*b
    while a % b:
        a, b = b, a % b
    return m // b


5.判断完数(注意循环与分支缩进位置)
 A.自定义函数解题
 def is_perfect(num):            # 定义一个函数，用于判断一个数是否为完数
    divisor_sum = 0              # 定义一个变量，用于存储这个数的所有因子之和
    for i in range(1, num):      # 遍历这个数前面的每个数，赋值给i
        if num % i == 0:         # 如果 i 是 num 的因子(就是除得尽)
            divisor_sum += i     # 将 i 添加到 divisor_sum 中
    if divisor_sum == num:       # 如果 divisor_sum 等于 num(上一步循环完后的和与传入的数进行对比)，说明 num 是一个完数
        return True
    else:           #否则，num 不是一个完数
        return False


6.判断闰年
 def is_run(year):
    if year % 4 == 0 and year % 100 != 0 or year % 400 == 0:
       return Ture
    else:
         return False




#################多重输入#################
1.如果每一行输入独立
使用while True与异常处理联用

2.如果输入内容需从头处理到尾
 使用 import sys  s=sys.stdin.read()
 常与 对象.split()联用，保存成列表
 若涉及截止符号,使用.split("截止符号")，分离出前面内容

3.出现组数与测试数据，一般由外到里进行循环处理


#################文本处理与统计综合大题#################
1.文本处理部分
 A.引入文章，多行输入方法见上
 B.使用循环+分支+转成列表,处理文章不需要的内容(例如标点符号之类的)
 for 循环变量 in 循环对象:
      if not 循环变量.isalnum() 不是字母或数字的话
      循环对象 = 循环对象.replace(循环变量, " ") 把文本中不是字母或数字替换成空格，方便后期分割
 新的变量 = 循环对象.split() 保存好处理好的文本，并以空格分割成列表

2.统计部分
 A.创建空字典
 B.使用循环+字典方法 在空字典中统计出现频率
  for 循环变量 in 处理好的文本对象:
  空字典的变量名[循环变量] = 空字典.get(循环变量, 返回值(统计中常用0)) + 1  以循环变量创建字典key，单词数量为value(通过get函数增加数量，
  没有返回0，存在就返回字典对应的值，像累加一样)

3.排序部分,常用sorted函数与lambda函数(决定排序规则)联用
 A.将上述统计好的字典用items解包成元组放入sorted函数中
 变量 = sorted(统计好的字典.items, key = lambda [参数]:[表达式])

 B.设定排序规则(key)
  key = lambda [参数]:[表达式]  (多种规则时，表达式需圆括号包起来)
  表达式:统计综合大题中，因为是元组，可以通过索引方式确定表达式，从而指定规则
        其他排序中，常用切片，逆向切片或者相关函数(比如len，max,sum)，来确定表达式，从而指定排序规则
        例如：key=lambda x: len(x) 以长度决定排序方式
   又或者:max([10, 78, 39, 5, 901, 551], key=lambda x:sum(map(int, str(x)))) 每一位数数字相加的最大值作为排序规则
